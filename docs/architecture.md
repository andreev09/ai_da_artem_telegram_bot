# Архитектура и поток данных

## Обзор приложения

Репозиторий реализует Telegram-бота, работающего через вебхук. Основные цели:

1. Ответить на команду `/start` приветственным сообщением и показать кнопку, запрашивающую контакт.
2. Принять контакт пользователя, сохранить его и отправить подтверждение.
3. (Опционально) конвертировать присланные `.xls` файлы в `.xlsx` и отдать их обратно пользователю.

Flask-приложение можно запускать как через `app.py` (минимальный обработчик), так и через `main.py`, который делегирует логику классу `TelegramWebhookHandler` и покрыт тестами.

## Ключевые модули

| Модуль | Ответственность |
| --- | --- |
| `main.py` | Точка входа с использованием `TelegramWebhookHandler`. Декларирует эндпоинты `/webhook` и `/`. |
| `app.py` | Упрощённая версия вебхука, пригодная для smoke-тестов или демонстрации. |
| `server_config.py` | Настраивает переменные окружения для корректного биндинга Flask к `0.0.0.0` и порту из `PORT`. |
| `webhook_handlers.py` | Содержит `TelegramWebhookHandler` (универсальная обработка апдейтов) и `TextMessageHandler` (ответы на команды). Управляет логированием, хранением контактов и конвертацией файлов. |
| `texts.py` | Загрузка текстов интерфейса из `texts.json`, предоставление дефолтных значений и форматирования шаблонов. |
| `texts.json` | Пользовательские тексты (приветствие, подписи кнопок, шаблон подтверждения). Если файл отсутствует, используются значения из `texts.py`. |
| `xls_to_xlsx.py` | Функция `convert_xls_bytes_to_xlsx_bytes`, преобразующая старый формат Excel в современный. Подключается динамически, чтобы не ломать основной сценарий, если зависимость не установлена. |
| `tests/` | Набор модульных и интеграционных тестов, проверяющих тексты и конвертацию файлов. |

## Поток обработки вебхука

1. Telegram отправляет POST-запрос на `/webhook` с JSON-апдейтом.
2. Flask-декоратор парсит JSON и передаёт объект в `TelegramWebhookHandler.handle_update`.
3. Обработчик анализирует структуру апдейта (документ → контакт → текст) и выбирает соответствующую ветку логики:
   - Документ: проверка расширения и размера, скачивание через `getFile`, конвертация в `.xlsx`, отправка обратно через `sendDocument`.
   - Контакт: сохранение данных (`authorized_contacts.jsonl` по умолчанию) и формирование благодарственного сообщения.
   - Текст: делегирование `TextMessageHandler`, который сейчас реагирует на `/start` и возвращает приветствие с клавиатурой.
4. Результат (словарь с инструкцией для Telegram API или служебный статус) сериализуется во Flask и отдаётся в ответе.

## Хранение и конфигурация

- **Переменные окружения**
  - `TELEGRAM_BOT_TOKEN` — обязателен для сценария с конвертацией файлов; используется при запросах `getFile`/`sendDocument`.
  - `TELEGRAM_LOG_LEVEL` — уровень логов (по умолчанию INFO).
- **Файлы**
  - Контакты пишутся в `authorized_contacts.jsonl` рядом с кодом (по одному JSON в строке). Путь можно переопределить при инициализации `TelegramWebhookHandler`.
  - Кастомные тексты хранятся в `texts.json` и подхватываются автоматически.
- **Сторонние сервисы** — Telegram Bot API (HTTP), конвертер Excel использует `requests`, `xlwt`, `openpyxl`.

## Расширение функциональности

- Новые команды добавляются через регистрацию обработчиков в `TextMessageHandler._command_handlers`.
- Дополнительные реакции на типы апдейтов удобно внедрять в `TelegramWebhookHandler.handle_update`, соблюдая приоритеты (документы → контакты → текст).
- Для интеграции с внешними системами можно заменить `_persist_contact_data` или прокинуть свои зависимости через параметры конструктора.

Обновляя архитектуру, старайтесь фиксировать в этом документе:

- Новые точки входа или вебхуки.
- Изменения формата данных (JSON, файлы, хранилища).
- Дополнительные переменные окружения и требования к инфраструктуре.

